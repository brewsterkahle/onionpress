#!/bin/bash

# OnionPress launcher script
# This script manages the WordPress + Tor onion service containers

set -e

# Ensure we run natively on Apple Silicon (not under Rosetta).
# Universal binaries inherit the parent's architecture, so if this script
# was started under Rosetta we must re-exec to get native arm64 execution.
if sysctl hw.optional.arm64 2>/dev/null | grep -q ": 1" && [ "$(uname -m)" = "x86_64" ]; then
    exec arch -arm64 "$0" "$@"
fi

# Get the directory where this script is located
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
APP_DIR="$(dirname "$SCRIPT_DIR")"
RESOURCES_DIR="$APP_DIR/Resources"
DOCKER_DIR="$RESOURCES_DIR/docker"
SCRIPTS_DIR="$RESOURCES_DIR/scripts"
DATA_DIR="$HOME/.onionpress"
BIN_DIR="$RESOURCES_DIR/bin"
COLIMA_HOME="$DATA_DIR/colima"

# Ensure data directory exists
mkdir -p "$DATA_DIR"

# Detect architecture (use sysctl to get actual hardware, not process architecture)
if sysctl hw.optional.arm64 2>/dev/null | grep -q ": 1"; then
    VM_ARCH="aarch64"
elif [ "$(uname -m)" = "x86_64" ]; then
    VM_ARCH="x86_64"
fi

# Create Docker config without credential store (avoids docker-credential-osxkeychain errors)
mkdir -p "$DATA_DIR/docker-config"
if [ ! -f "$DATA_DIR/docker-config/config.json" ]; then
    cat > "$DATA_DIR/docker-config/config.json" <<'EOFCONFIG'
{
	"auths": {},
	"currentContext": "colima"
}
EOFCONFIG
fi

# Install docker-compose plugin: prefer bundled, fall back to system
mkdir -p "$DATA_DIR/docker-config/cli-plugins"
if [ -f "$BIN_DIR/docker-compose" ]; then
    ln -sf "$BIN_DIR/docker-compose" "$DATA_DIR/docker-config/cli-plugins/docker-compose"
elif [ -L "$HOME/.docker/cli-plugins/docker-compose" ] && [ ! -e "$DATA_DIR/docker-config/cli-plugins/docker-compose" ]; then
    ln -sf "$HOME/.docker/cli-plugins/docker-compose" "$DATA_DIR/docker-config/cli-plugins/docker-compose"
fi

# Create default config if it doesn't exist
if [ ! -f "$DATA_DIR/config" ]; then
    if [ -f "$RESOURCES_DIR/config-template.txt" ]; then
        cp "$RESOURCES_DIR/config-template.txt" "$DATA_DIR/config"
    else
        cat > "$DATA_DIR/config" <<EOF
ADDRESS_PREFIX=op2
INSTALL_IA_PLUGIN=yes
UPDATE_ON_LAUNCH=no
LAUNCH_ON_LOGIN=no
EOF
    fi
fi

# Prefer bundled binaries
export PATH="$BIN_DIR:$PATH"
export COLIMA_HOME="$COLIMA_HOME"
export LIMA_HOME="$COLIMA_HOME/_lima"
export LIMA_INSTANCE="onionpress"
export DOCKER_HOST="unix://$COLIMA_HOME/default/docker.sock"
export DOCKER_CONFIG="$DATA_DIR/docker-config"

# Read version from Info.plist
ONIONPRESS_VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$APP_DIR/Info.plist" 2>/dev/null || echo "unknown")
export ONIONPRESS_VERSION

# Read Cloudflare Tunnel token from config (empty = disabled)
CLOUDFLARE_TUNNEL_TOKEN=""
if [ -f "$DATA_DIR/config" ]; then
    _cf_token=$(grep "^CLOUDFLARE_TUNNEL_TOKEN=" "$DATA_DIR/config" | cut -d= -f2)
    if [ ! -z "$_cf_token" ]; then
        CLOUDFLARE_TUNNEL_TOKEN="$_cf_token"
    fi
fi
export CLOUDFLARE_TUNNEL_TOKEN

# OnionCellar mode detection — check if our .onion address matches the cellar address
# This env var is passed to docker-compose and controls cellar-specific behavior
export ONIONPRESS_CELLAR="0"

detect_cellar_mode() {
    local cellar_address="ocellarg3xj7hpw25etw34glkjsels5q6knyxe6rmomsjplckwnexdqd.onion"
    local our_address=""
    our_address=$(docker compose exec -T tor cat /var/lib/tor/hidden_service/wordpress/hostname 2>/dev/null || echo "")
    our_address=$(echo "$our_address" | tr -d '\n\r ')
    if [ "$our_address" = "$cellar_address" ]; then
        export ONIONPRESS_CELLAR="1"
        log "OnionCellar mode activated (address: $our_address)"
        return 0
    fi
    return 1
}

# Log file
LOG_FILE="$DATA_DIR/onionpress.log"

# Function to log messages
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Function to check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Check if WordPress core is installed (setup wizard completed)
wp_is_installed() {
    docker exec onionpress-wordpress wp core is-installed --allow-root >/dev/null 2>&1
}

# Function to generate and load database passwords
setup_db_passwords() {
    local secrets_file="$DATA_DIR/secrets"

    # Create secrets file if it doesn't exist
    if [ ! -f "$secrets_file" ]; then
        log "Generating random database passwords..."

        # Generate random 32-character passwords using /dev/urandom
        # Use only alphanumeric chars to avoid shell quoting issues when sourcing
        local wordpress_pass=$(LC_ALL=C tr -dc 'A-Za-z0-9' < /dev/urandom | head -c 32)
        local root_pass=$(LC_ALL=C tr -dc 'A-Za-z0-9' < /dev/urandom | head -c 32)

        # Write passwords to secrets file with restricted permissions
        # Values are single-quoted to prevent shell interpretation on source
        touch "$secrets_file"
        chmod 600 "$secrets_file"

        cat > "$secrets_file" <<EOF
# Database passwords - generated on $(date)
# DO NOT SHARE THESE PASSWORDS
WORDPRESS_DB_PASSWORD='$wordpress_pass'
MYSQL_PASSWORD='$wordpress_pass'
MYSQL_ROOT_PASSWORD='$root_pass'
EOF

        log "Database passwords generated and saved to $secrets_file"
    fi

    # Load passwords from secrets file
    if [ -f "$secrets_file" ]; then
        source "$secrets_file"
        export WORDPRESS_DB_PASSWORD
        export MYSQL_PASSWORD
        export MYSQL_ROOT_PASSWORD
    else
        log "ERROR: Secrets file not found at $secrets_file"
        exit 1
    fi
}

# Function to detect container runtime
detect_container_runtime() {
    # Use bundled Colima
    if command_exists colima; then
        if [ -f "$COLIMA_HOME/.initialized" ]; then
            if "$BIN_DIR/colima" status >/dev/null 2>&1; then
                echo "colima-bundled"
                return 0
            else
                # Start Colima if stopped
                log "Starting bundled Colima..."
                "$BIN_DIR/colima" start >> "$LOG_FILE" 2>&1
                if [ $? -eq 0 ]; then
                    echo "colima-bundled"
                    return 0
                fi
            fi
        fi
    fi

    # Fallback to system Docker (for development)
    if command_exists docker && docker info >/dev/null 2>&1; then
        echo "docker-system"
        return 0
    fi

    return 1
}

# Function to generate custom onion address with prefix
generate_vanity_address() {
    local prefix="${1:-op2}"
    # Use shared directory so Docker/Colima can access it
    local output_dir="$DATA_DIR/shared/vanity-keys"

    log "Generating custom onion address with prefix '$prefix'..." >&2

    # Create output directory
    mkdir -p "$output_dir"

    # Check if mkp224o is available
    if [ ! -f "$BIN_DIR/mkp224o" ]; then
        log "WARNING: mkp224o not found, using random address" >&2
        return 1
    fi

    # Generate address with prefix (single threaded for consistency)
    cd "$output_dir"
    "$BIN_DIR/mkp224o" -d . -n 1 -t 4 "$prefix" >> "$LOG_FILE" 2>&1

    # Find generated directory
    VANITY_DIR=$(find "$output_dir" -type d -name "${prefix}*" | head -1)

    if [ -z "$VANITY_DIR" ]; then
        log "ERROR: Failed to generate custom address" >&2
        return 1
    fi

    VANITY_ADDRESS=$(basename "$VANITY_DIR")
    log "Generated custom address: $VANITY_ADDRESS" >&2

    # Return the directory path (only thing on stdout)
    echo "$VANITY_DIR"
    return 0
}

# Function to import a pre-generated onion service key
import_key() {
    local key_b32="$1"

    # Show help if no argument or --help
    if [ -z "$key_b32" ] || [ "$key_b32" = "--help" ] || [ "$key_b32" = "-h" ]; then
        cat <<'HELPEOF'
Usage: onionpress import-key <base32-secret-key>

Import a pre-generated ed25519 key for your onion service.

The base32 key should encode the 64-byte expanded ed25519 secret key.
OnionPress will derive the .onion address automatically.

HOW TO GET THE KEY FROM mkp224o OUTPUT:

  OnionPress stores vanity keys in ~/.onionpress/shared/vanity-keys/.
  Each address has its own directory containing hs_ed25519_secret_key.
  Encode that file to base32:

    python3 -c "import base64; print(base64.b32encode(open('$HOME/.onionpress/shared/vanity-keys/<address>.onion/hs_ed25519_secret_key','rb').read()).decode())"

  If you ran mkp224o yourself, substitute the path to your output directory.

  OnionPress accepts both the full file (96 bytes with header) and the
  64-byte key alone (read()[32:]).

EXAMPLE:

  KEY=$(python3 -c "import base64; print(base64.b32encode(open('$HOME/.onionpress/shared/vanity-keys/<address>.onion/hs_ed25519_secret_key','rb').read()).decode())")
  ./onionpress import-key "$KEY"

WHAT THIS COMMAND DOES:

  1. Decodes the base32 key and validates it is exactly 64 bytes
  2. Derives the .onion address from the public key portion
  3. Writes key files to ~/.onionpress/shared/vanity-keys/<address>/
     - hs_ed25519_secret_key  (32-byte header + 64-byte key)
     - hs_ed25519_public_key  (32-byte header + 32-byte pubkey)
     - hostname               (the .onion address)
  4. On next start, OnionPress will use this key

NOTE: If OnionPress has already started and created a tor-keys volume,
you must stop OnionPress and delete the volume first:

    ./onionpress stop
    docker volume rm onionpress-tor-keys

HELPEOF
        return 0
    fi

    # Check if tor-keys volume already exists
    if docker volume ls --format '{{.Name}}' 2>/dev/null | grep -q '^onionpress-tor-keys$'; then
        echo "ERROR: onionpress-tor-keys volume already exists." >&2
        echo "" >&2
        echo "OnionPress has already created a tor key volume. To import a new key:" >&2
        echo "  1. Stop OnionPress:  ./onionpress stop" >&2
        echo "  2. Delete the volume: docker volume rm onionpress-tor-keys" >&2
        echo "  3. Re-run:           ./onionpress import-key <key>" >&2
        return 1
    fi

    # Decode base32, validate length, derive public key and address — all in one python3 call
    # The public key must be derived via ed25519 scalar multiplication (not a simple slice)
    local result
    result=$(python3 -c "
import base64, hashlib, sys, binascii

key_b32 = sys.argv[1]

# Decode base32
try:
    key_bytes = base64.b32decode(key_b32, casefold=True)
except Exception as e:
    print(f'ERROR: Invalid base32 encoding: {e}', file=sys.stderr)
    sys.exit(1)

# Accept 96 bytes (full file with 32-byte header) or 64 bytes (key only)
if len(key_bytes) == 96 and key_bytes[:29] == b'== ed25519v1-secret: type0 ==':
    key_bytes = key_bytes[32:]
elif len(key_bytes) != 64:
    print(f'ERROR: Key must be exactly 64 bytes (or 96 with header), got {len(key_bytes)}', file=sys.stderr)
    sys.exit(1)

# Derive public key from expanded secret key via ed25519 scalar multiplication
p = 2**255 - 19
def inv(x): return pow(x, p-2, p)
d = -121665 * inv(121666) % p

def recover_x(y, sign):
    x2 = (y*y-1) * inv(d*y*y+1) % p
    x = pow(x2, (p+3)//8, p)
    if (x*x - x2) % p != 0:
        x = x * pow(2, (p-1)//4, p) % p
    if x % 2 != sign: x = p - x
    return x

By = 4 * inv(5) % p
Bx = recover_x(By, 0)
B = (Bx, By, 1, Bx*By % p)

def point_add(P, Q):
    x1,y1,z1,t1 = P; x2,y2,z2,t2 = Q
    a=(y1-x1)*(y2-x2)%p; b=(y1+x1)*(y2+x2)%p
    c=2*t1*t2*d%p; dd=2*z1*z2%p
    e=b-a; f=dd-c; g=dd+c; h=b+a
    return (e*f%p, g*h%p, f*g%p, e*h%p)

def scalar_mult(s, P):
    Q = (0, 1, 1, 0)
    while s > 0:
        if s & 1: Q = point_add(Q, P)
        P = point_add(P, P)
        s >>= 1
    return Q

def encode_point(P):
    x,y,z,_ = P; zi = inv(z)
    x,y = x*zi%p, y*zi%p
    r = bytearray(y.to_bytes(32,'little'))
    r[31] ^= (x&1) << 7
    return bytes(r)

scalar = int.from_bytes(key_bytes[:32], 'little')
pubkey = encode_point(scalar_mult(scalar, B))

# Derive .onion address (v3 spec)
checksum = hashlib.sha3_256(b'.onion checksum' + pubkey + b'\x03').digest()[:2]
address = base64.b32encode(pubkey + checksum + b'\x03').decode().lower() + '.onion'

# Output: address on line 1, hex key on line 2, hex pubkey on line 3
print(address)
print(binascii.hexlify(key_bytes).decode())
print(binascii.hexlify(pubkey).decode())
" "$key_b32" 2>&1)

    if [ $? -ne 0 ]; then
        echo "$result" >&2
        return 1
    fi

    # Parse python output
    local address hex_key hex_pubkey
    address=$(echo "$result" | sed -n '1p')
    hex_key=$(echo "$result" | sed -n '2p')
    hex_pubkey=$(echo "$result" | sed -n '3p')

    if [ -z "$address" ] || [ -z "$hex_key" ] || [ -z "$hex_pubkey" ]; then
        echo "ERROR: Failed to derive address from key" >&2
        return 1
    fi

    # Create output directory
    local output_dir="$DATA_DIR/shared/vanity-keys/$address"
    mkdir -p "$output_dir"

    # Write hs_ed25519_secret_key: 32-byte header + 64-byte key
    # Header: "== ed25519v1-secret: type0 ==\x00\x00\x00" (32 bytes)
    python3 -c "
import binascii, sys
header = b'== ed25519v1-secret: type0 ==\x00\x00\x00'
key = binascii.unhexlify(sys.argv[1])
sys.stdout.buffer.write(header + key)
" "$hex_key" > "$output_dir/hs_ed25519_secret_key"

    # Write hs_ed25519_public_key: 32-byte header + 32-byte pubkey
    # Header: "== ed25519v1-public: type0 ==\x00\x00\x00" (32 bytes)
    python3 -c "
import binascii, sys
header = b'== ed25519v1-public: type0 ==\x00\x00\x00'
pubkey = binascii.unhexlify(sys.argv[1])
sys.stdout.buffer.write(header + pubkey)
" "$hex_pubkey" > "$output_dir/hs_ed25519_public_key"

    # Write hostname file
    echo "$address" > "$output_dir/hostname"

    # Set restrictive permissions
    chmod 600 "$output_dir/hs_ed25519_secret_key"
    chmod 600 "$output_dir/hs_ed25519_public_key"
    chmod 644 "$output_dir/hostname"

    log "Imported key for address: $address"
    echo "Imported key for: $address"
    echo "Key files written to: $output_dir"
    echo ""
    echo "Start OnionPress to use this address."
    return 0
}

# Function to install and activate Internet Archive Wayback Machine Link Fixer plugin
install_ia_plugin() {
    # Check if plugin installation is enabled in config
    local install_plugin="yes"
    if [ -f "$DATA_DIR/config" ]; then
        local config_value=$(grep "^INSTALL_IA_PLUGIN=" "$DATA_DIR/config" | cut -d= -f2)
        if [ ! -z "$config_value" ]; then
            install_plugin="$config_value"
        fi
    fi

    if [ "$install_plugin" != "yes" ]; then
        log "Internet Archive plugin installation disabled in config"
        return 0
    fi

    # Check if installation scripts exist
    if [ ! -d "$SCRIPTS_DIR" ] || [ ! -f "$SCRIPTS_DIR/install_plugin.sh" ]; then
        log "Plugin installation scripts not available, skipping"
        return 0
    fi

    log "Checking Internet Archive Wayback Machine Link Fixer plugin..."

    cd "$DOCKER_DIR"

    # Check if plugin is already installed
    if docker compose exec -T wordpress test -f /var/www/html/wp-content/plugins/internet-archive-wayback-machine-link-fixer/internet-archive-wayback-machine-link-fixer.php 2>/dev/null; then
        # Plugin is installed, try to activate if WordPress is configured
        log "Internet Archive plugin already installed, checking activation status..."
        if "$SCRIPTS_DIR/activate_plugin.sh" "onionpress-wordpress" \
            "internet-archive-wayback-machine-link-fixer/internet-archive-wayback-machine-link-fixer.php" >>"$LOG_FILE" 2>&1; then
            log "✓ Internet Archive Wayback Machine Link Fixer plugin is active"
        else
            log "Plugin will auto-activate after WordPress setup"
        fi
        return 0
    fi

    log "Installing Internet Archive Wayback Machine Link Fixer plugin..."

    # Create temp directory for plugin download
    local temp_dir=$(mktemp -d)

    # Download and verify plugin using bash script with checksum verification
    if "$SCRIPTS_DIR/install_plugin.sh" "internet-archive-wayback-machine-link-fixer" "$temp_dir" >>"$LOG_FILE" 2>&1; then
        # Copy plugin to WordPress container
        if docker cp "$temp_dir/internet-archive-wayback-machine-link-fixer" onionpress-wordpress:/var/www/html/wp-content/plugins/ 2>>"$LOG_FILE" && \
            cd "$DOCKER_DIR" && \
            docker compose exec -T wordpress chown -R www-data:www-data /var/www/html/wp-content/plugins/internet-archive-wayback-machine-link-fixer 2>>"$LOG_FILE"; then
            log "✓ Internet Archive Wayback Machine Link Fixer plugin installed with verified checksum!"

            # Try to activate immediately if WordPress is configured
            if "$SCRIPTS_DIR/activate_plugin.sh" "onionpress-wordpress" \
                "internet-archive-wayback-machine-link-fixer/internet-archive-wayback-machine-link-fixer.php" >>"$LOG_FILE" 2>&1; then
                log "✓ Plugin automatically activated!"
            else
                log "Plugin will auto-activate after WordPress setup"
            fi
        else
            log "Failed to copy plugin to container"
        fi
    else
        log "Failed to download and verify plugin - check log for details"
    fi

    # Clean up
    rm -rf "$temp_dir"

    return 0
}

# Function to configure IA Wayback Machine Link Fixer plugin options via WP-CLI
configure_ia_plugin() {
    # Check if plugin installation is enabled in config
    local install_plugin="yes"
    if [ -f "$DATA_DIR/config" ]; then
        local config_value=$(grep "^INSTALL_IA_PLUGIN=" "$DATA_DIR/config" | cut -d= -f2)
        if [ ! -z "$config_value" ]; then
            install_plugin="$config_value"
        fi
    fi

    if [ "$install_plugin" != "yes" ]; then
        return 0
    fi

    # Skip if WordPress is not installed yet
    if ! wp_is_installed; then
        return 0
    fi

    # Skip if plugin is not installed
    if ! docker exec onionpress-wordpress test -f /var/www/html/wp-content/plugins/internet-archive-wayback-machine-link-fixer/internet-archive-wayback-machine-link-fixer.php 2>/dev/null; then
        return 0
    fi

    # Check if already configured (idempotent — don't overwrite user customizations)
    local wizard_done
    wizard_done=$(docker exec onionpress-wordpress wp option get iawmlf_setup_wizard_completed --allow-root 2>/dev/null || echo "")
    if [ "$wizard_done" = "1" ]; then
        log "✓ Internet Archive plugin already configured"
        return 0
    fi

    log "Configuring Internet Archive Wayback Machine Link Fixer plugin..."

    # Enable link fixer (scans outbound links, replaces broken ones with archived versions)
    docker exec onionpress-wordpress wp option update iawmlf_process_links 1 --allow-root >> "$LOG_FILE" 2>&1
    docker exec onionpress-wordpress wp option update iawmlf_fixer_option replace_link --allow-root >> "$LOG_FILE" 2>&1
    docker exec onionpress-wordpress wp option update iawmlf_scan_existing_posts 1 --allow-root >> "$LOG_FILE" 2>&1

    # Mark setup wizard complete (prevents wizard UI from showing)
    docker exec onionpress-wordpress wp option update iawmlf_setup_wizard_completed 1 --allow-root >> "$LOG_FILE" 2>&1

    # Do NOT enable the plugin's own auto-archive — our mu-plugin handles it
    # with proper .onion URLs and Tor routing

    log "✓ Internet Archive plugin configured (link fixer enabled, wizard completed)"
    return 0
}

# Function to fix permissions for onionpress persistent data directory
fix_onionpress_permissions() {
    log "Fixing permissions for onionpress persistent data directory..."

    cd "$DOCKER_DIR"

    # Ensure the directory exists and is owned by www-data
    # Use 750 (rwxr-x---) to prevent other users from reading the directory
    if docker compose exec -T wordpress sh -c 'chown -R www-data:www-data /var/lib/onionpress && chmod 750 /var/lib/onionpress' 2>>"$LOG_FILE"; then
        log "✓ Onionpress data directory permissions fixed"
        return 0
    else
        log "WARNING: Could not fix onionpress data directory permissions"
        return 1
    fi
}

# Function to initialize container runtime
install_docker() {
    log "Container runtime initialization required"

    # Read VM memory from config (default: 1 GB)
    VM_MEMORY=1
    if [ -f "$DATA_DIR/config" ]; then
        config_mem=$(grep "^VM_MEMORY=" "$DATA_DIR/config" | cut -d= -f2)
        if [ ! -z "$config_mem" ]; then
            VM_MEMORY="$config_mem"
        fi
    fi

    # Should not happen if launcher worked, but handle it
    if [ "$VM_ARCH" = "aarch64" ]; then
        # Apple Silicon: use VZ backend (Virtualization.framework)
        "$BIN_DIR/colima" start \
            --vm-type vz \
            --mount-type virtiofs \
            --mount "$DATA_DIR:w" \
            --cpu 2 \
            --memory "$VM_MEMORY" \
            --arch "$VM_ARCH" \
            --vz-rosetta=false \
            >> "$LOG_FILE" 2>&1
    else
        # Intel: use QEMU backend
        "$BIN_DIR/colima" start \
            --vm-type qemu \
            --mount-type sshfs \
            --mount "$DATA_DIR:w" \
            --cpu 2 \
            --memory "$VM_MEMORY" \
            --arch "$VM_ARCH" \
            >> "$LOG_FILE" 2>&1
    fi

    if [ $? -eq 0 ]; then
        touch "$COLIMA_HOME/.initialized"
        log "Container runtime initialized successfully"
        return 0
    else
        log "ERROR: Failed to initialize container runtime"
        echo "ERROR: Failed to initialize container runtime." >&2
        echo "Check the logs for details: $LOG_FILE" >&2
        echo "Or file an issue at: https://github.com/brewsterkahle/onionpress/issues" >&2
        exit 1
    fi
}

# Function to update Docker images if enabled
update_images() {
    # Check if auto-update is enabled in config
    local update_enabled="no"
    if [ -f "$DATA_DIR/config" ]; then
        local config_value=$(grep "^UPDATE_ON_LAUNCH=" "$DATA_DIR/config" | cut -d= -f2)
        if [ ! -z "$config_value" ]; then
            update_enabled="$config_value"
        fi
    fi

    if [ "$update_enabled" != "yes" ]; then
        return 0
    fi

    log "Checking for Docker image updates..."

    cd "$DOCKER_DIR"

    # Pull latest images (WordPress, MariaDB, Tor)
    local images=("wordpress:latest" "mariadb:latest")
    local updated=false

    for image in "${images[@]}"; do
        log "Pulling $image..."
        if docker pull "$image" >> "$LOG_FILE" 2>&1; then
            log "✓ $image up to date"
            updated=true
        else
            log "WARNING: Failed to pull $image (continuing with cached version)"
        fi
    done

    if [ "$updated" = true ]; then
        log "✓ Image update check complete"
    fi

    return 0
}

# Function to ensure WordPress multisite is active (runs on every startup)
ensure_multisite() {
    # Skip if WordPress is not installed yet
    if ! wp_is_installed; then
        log "WordPress not installed yet — skipping multisite check"
        return 0
    fi

    cd "$DOCKER_DIR"

    # Check if multisite is already active
    if docker exec onionpress-wordpress wp core is-installed --network --allow-root >/dev/null 2>&1; then
        log "✓ WordPress multisite already active"
        return 0
    fi

    log "Converting single-site WordPress to multisite..."

    # Convert to multisite (subdirectory mode)
    # --url=http://localhost is required because WP_HOME uses $_SERVER['HTTP_HOST']
    # which is undefined in CLI context, causing WP to store "http:" as the domain
    if ! docker exec onionpress-wordpress wp core multisite-convert \
        --url=http://localhost --allow-root >> "$LOG_FILE" 2>&1; then
        log "WARNING: wp core multisite-convert failed (may already be multisite)"
    fi

    # Set multisite constants
    local constants=(
        "MULTISITE:true"
        "SUBDOMAIN_INSTALL:false"
        "DOMAIN_CURRENT_SITE:'localhost'"
        "PATH_CURRENT_SITE:'/'"
        "SITE_ID_CURRENT_SITE:1"
        "BLOG_ID_CURRENT_SITE:1"
        "SUNRISE:true"
    )

    for entry in "${constants[@]}"; do
        local name="${entry%%:*}"
        local value="${entry#*:}"
        docker exec onionpress-wordpress wp config set "$name" "$value" \
            --raw --type=constant --allow-root >> "$LOG_FILE" 2>&1
    done

    # Write .htaccess with multisite rewrite rules
    docker exec onionpress-wordpress bash -c 'cat > /var/www/html/.htaccess << "HTEOF"
# BEGIN WordPress Multisite
RewriteEngine On
RewriteBase /
RewriteRule ^index\.php$ - [L]

# add a trailing slash to /wp-admin
RewriteRule ^([_0-9a-zA-Z-]+/)?wp-admin$ $1wp-admin/ [R=301,L]

RewriteCond %{REQUEST_FILENAME} -f [OR]
RewriteCond %{REQUEST_FILENAME} -d
RewriteRule ^ - [L]
RewriteRule ^([_0-9a-zA-Z-]+/)?(wp-(content|admin|includes).*) $2 [L]
RewriteRule ^([_0-9a-zA-Z-]+/)?(.*\.php)$ $2 [L]
RewriteRule . index.php [L]
# END WordPress Multisite
HTEOF
chown www-data:www-data /var/www/html/.htaccess' >> "$LOG_FILE" 2>&1

    log "✓ WordPress multisite conversion complete"
    return 0
}

# Function to install multisite domain mapping PHP files into the container
install_multisite_domain_map() {
    local plugins_dir="$RESOURCES_DIR/plugins"

    # Copy sunrise.php → wp-content/sunrise.php
    if [ -f "$plugins_dir/onionpress-sunrise.php" ]; then
        if docker cp "$plugins_dir/onionpress-sunrise.php" \
            onionpress-wordpress:/var/www/html/wp-content/sunrise.php >> "$LOG_FILE" 2>&1; then
            docker exec onionpress-wordpress chown www-data:www-data \
                /var/www/html/wp-content/sunrise.php >> "$LOG_FILE" 2>&1
            log "✓ sunrise.php installed"
        else
            log "WARNING: Failed to copy sunrise.php"
        fi
    fi

    # Ensure .htaccess has multisite rewrite rules (REST API needs these)
    docker exec onionpress-wordpress bash -c 'cat > /var/www/html/.htaccess << '\''HTEOF'\''
# Privacy: prevent onion address leaking in Referer headers
<IfModule mod_headers.c>
Header set Referrer-Policy "no-referrer"
</IfModule>

# BEGIN WordPress Multisite
RewriteEngine On
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
RewriteBase /
RewriteRule ^index\.php$ - [L]

# add a trailing slash to /wp-admin
RewriteRule ^([_0-9a-zA-Z-]+/)?wp-admin$ $1wp-admin/ [R=301,L]

RewriteCond %{REQUEST_FILENAME} -f [OR]
RewriteCond %{REQUEST_FILENAME} -d
RewriteRule ^ - [L]
RewriteRule ^([_0-9a-zA-Z-]+/)?(wp-(content|admin|includes).*) $2 [L]
RewriteRule ^([_0-9a-zA-Z-]+/)?(.*\.php)$ $2 [L]
RewriteRule . index.php [L]
# END WordPress Multisite
HTEOF
chown www-data:www-data /var/www/html/.htaccess' >> "$LOG_FILE" 2>&1 && \
        log "✓ .htaccess multisite rewrite rules installed" || \
        log "WARNING: Failed to write .htaccess"

    # Copy domain-map mu-plugin → wp-content/mu-plugins/
    if [ -f "$plugins_dir/onionpress-domain-map.php" ]; then
        docker exec onionpress-wordpress mkdir -p \
            /var/www/html/wp-content/mu-plugins >> "$LOG_FILE" 2>&1
        if docker cp "$plugins_dir/onionpress-domain-map.php" \
            onionpress-wordpress:/var/www/html/wp-content/mu-plugins/onionpress-domain-map.php >> "$LOG_FILE" 2>&1; then
            docker exec onionpress-wordpress chown www-data:www-data \
                /var/www/html/wp-content/mu-plugins/onionpress-domain-map.php >> "$LOG_FILE" 2>&1
            log "✓ onionpress-domain-map.php mu-plugin installed"
        else
            log "WARNING: Failed to copy onionpress-domain-map.php"
        fi
    fi

    # Copy Wayback Machine archiver mu-plugin → wp-content/mu-plugins/
    if [ -f "$plugins_dir/onionpress-wayback-archive.php" ]; then
        docker exec onionpress-wordpress mkdir -p \
            /var/www/html/wp-content/mu-plugins >> "$LOG_FILE" 2>&1
        if docker cp "$plugins_dir/onionpress-wayback-archive.php" \
            onionpress-wordpress:/var/www/html/wp-content/mu-plugins/onionpress-wayback-archive.php >> "$LOG_FILE" 2>&1; then
            docker exec onionpress-wordpress chown www-data:www-data \
                /var/www/html/wp-content/mu-plugins/onionpress-wayback-archive.php >> "$LOG_FILE" 2>&1
            log "✓ onionpress-wayback-archive.php mu-plugin installed"
        else
            log "WARNING: Failed to copy onionpress-wayback-archive.php"
        fi
    fi

    # Copy favicon mu-plugin
    if [ -f "$plugins_dir/onionpress-favicon.php" ]; then
        if docker cp "$plugins_dir/onionpress-favicon.php" \
            onionpress-wordpress:/var/www/html/wp-content/mu-plugins/onionpress-favicon.php >> "$LOG_FILE" 2>&1; then
            docker exec onionpress-wordpress chown www-data:www-data \
                /var/www/html/wp-content/mu-plugins/onionpress-favicon.php >> "$LOG_FILE" 2>&1
            log "✓ onionpress-favicon.php mu-plugin installed"
        else
            log "WARNING: Failed to copy onionpress-favicon.php"
        fi
    fi

    return 0
}

# Function to install OnionCellar registration mu-plugin (cellar mode only)
install_cellar_plugin() {
    if [ "$ONIONPRESS_CELLAR" != "1" ]; then
        return 0
    fi

    local plugins_dir="$RESOURCES_DIR/plugins"

    if [ -f "$plugins_dir/onionpress-cellar-register.php" ]; then
        docker exec onionpress-wordpress mkdir -p \
            /var/www/html/wp-content/mu-plugins >> "$LOG_FILE" 2>&1
        if docker cp "$plugins_dir/onionpress-cellar-register.php" \
            onionpress-wordpress:/var/www/html/wp-content/mu-plugins/onionpress-cellar-register.php >> "$LOG_FILE" 2>&1; then
            docker exec onionpress-wordpress chown www-data:www-data \
                /var/www/html/wp-content/mu-plugins/onionpress-cellar-register.php >> "$LOG_FILE" 2>&1
            log "✓ onionpress-cellar-register.php mu-plugin installed"
        else
            log "WARNING: Failed to copy onionpress-cellar-register.php"
        fi
    fi

    # Install cellar crypto helper library
    if [ -f "$plugins_dir/onionpress-cellar-crypto.php" ]; then
        if docker cp "$plugins_dir/onionpress-cellar-crypto.php" \
            onionpress-wordpress:/var/www/html/wp-content/mu-plugins/onionpress-cellar-crypto.php >> "$LOG_FILE" 2>&1; then
            docker exec onionpress-wordpress chown www-data:www-data \
                /var/www/html/wp-content/mu-plugins/onionpress-cellar-crypto.php >> "$LOG_FILE" 2>&1
            log "✓ onionpress-cellar-crypto.php installed"
        else
            log "WARNING: Failed to copy onionpress-cellar-crypto.php"
        fi
    fi

    # Create cellar data directory inside containers
    docker exec onionpress-wordpress mkdir -p \
        /var/lib/onionpress/cellar/keys >> "$LOG_FILE" 2>&1
    docker exec onionpress-wordpress chown -R www-data:www-data \
        /var/lib/onionpress/cellar >> "$LOG_FILE" 2>&1

    # Ensure cellar starts locked — delete unlocked key file
    # (functionally equivalent to tmpfs: key is lost on restart)
    docker exec onionpress-wordpress rm -f \
        /var/lib/onionpress/cellar/.master-key-unlocked >> "$LOG_FILE" 2>&1
    docker exec onionpress-tor rm -f \
        /var/lib/onionpress/cellar/.master-key-unlocked >> "$LOG_FILE" 2>&1
    log "✓ Cellar locked on startup (master key cleared)"

    return 0
}

# Function to start containers
start_containers() {
    log "Starting OnionPress containers..."

    cd "$DOCKER_DIR"

    # Check if this is first run (no tor keys exist)
    if ! docker volume ls | grep -q "onionpress-tor-keys"; then
        log "First run detected - generating custom onion address..."

        # Read address prefix from config, default to "op2"
        ADDRESS_PREFIX="op2"
        if [ -f "$DATA_DIR/config" ]; then
            CUSTOM_PREFIX=$(grep "^ADDRESS_PREFIX=" "$DATA_DIR/config" | cut -d= -f2)
            if [ ! -z "$CUSTOM_PREFIX" ]; then
                ADDRESS_PREFIX="$CUSTOM_PREFIX"
            fi
        fi

        log "Using address prefix: '$ADDRESS_PREFIX'"

        # Validate prefix: base32 only (a-z, 2-7), max 5 chars
        if [ ${#ADDRESS_PREFIX} -gt 5 ]; then
            log "ERROR: ADDRESS_PREFIX '$ADDRESS_PREFIX' is too long (${#ADDRESS_PREFIX} chars, max 5). Using default 'op2'."
            ADDRESS_PREFIX="op2"
        elif ! echo "$ADDRESS_PREFIX" | grep -qE '^[a-z2-7]+$'; then
            log "ERROR: ADDRESS_PREFIX '$ADDRESS_PREFIX' contains invalid characters. Only a-z and 2-7 allowed. Using default 'op2'."
            ADDRESS_PREFIX="op2"
        fi

        # Generate custom onion address
        if VANITY_DIR=$(generate_vanity_address "$ADDRESS_PREFIX"); then
            log "Custom onion address generated successfully"

            # Create volume and copy keys
            if ! docker volume create onionpress-tor-keys >> "$LOG_FILE" 2>&1; then
                log "ERROR: Failed to create tor-keys volume"
                return 1
            fi
            if ! docker run --rm \
                -v onionpress-tor-keys:/dest \
                --mount type=bind,source="$VANITY_DIR",target=/src \
                alpine sh -c 'mkdir -p /dest/wordpress && cp -r /src/* /dest/wordpress/ && chown -R 100:101 /dest/wordpress && chmod 700 /dest/wordpress && chmod 600 /dest/wordpress/*' >> "$LOG_FILE" 2>&1; then
                log "ERROR: Failed to copy address keys to tor volume"
                return 1
            fi

            log "Address keys installed to tor volume"
        else
            log "Using random onion address"
        fi
    fi

    # Update images if enabled in config
    update_images

    # Always start WordPress and DB first
    local max_attempts=3
    local attempt=1
    while [ $attempt -le $max_attempts ]; do
        if docker compose up -d --build wordpress db >> "$LOG_FILE" 2>&1; then
            break
        fi
        log "WARNING: 'docker compose up -d wordpress db' failed (attempt $attempt/$max_attempts). Check $LOG_FILE for details."
        if [ $attempt -eq $max_attempts ]; then
            log "ERROR: 'docker compose up -d wordpress db' failed after $max_attempts attempts."
            return 1
        fi
        attempt=$((attempt + 1))
        sleep 5
    done
    log "WordPress and DB containers starting"

    # Wait for WordPress container to be ready before checking install status
    local wp_wait=0
    while [ $wp_wait -lt 60 ]; do
        if curl -s --max-time 3 http://localhost:8080 >/dev/null 2>&1; then
            break
        fi
        sleep 2
        wp_wait=$((wp_wait + 2))
    done

    # Check if WordPress is already set up (admin account created)
    # Retry a few times — the DB may still be warming up even though
    # WordPress HTTP is responding (wp core is-installed needs a live DB)
    local wp_installed=false
    local wp_check=0
    while [ $wp_check -lt 5 ]; do
        if wp_is_installed; then
            wp_installed=true
            break
        fi
        sleep 2
        wp_check=$((wp_check + 1))
    done

    if $wp_installed; then
        log "WordPress is installed — starting Tor"
        docker compose up -d --build tor >> "$LOG_FILE" 2>&1
    else
        log "WordPress not yet installed — waiting for setup (Tor NOT started)"
    fi

    # Install Internet Archive Wayback Machine Link Fixer plugin
    install_ia_plugin

    # Configure IA plugin options (link fixer, wizard completion)
    configure_ia_plugin

    # Install multisite domain mapping PHP files (sunrise.php + mu-plugin)
    install_multisite_domain_map

    # Ensure multisite is active (converts single-site installs if needed)
    ensure_multisite

    # Fix permissions for onionpress persistent data directory
    fix_onionpress_permissions

    # Detect cellar mode and install cellar plugin if applicable
    cd "$DOCKER_DIR"
    detect_cellar_mode
    install_cellar_plugin

    # Conditionally start Cloudflare Tunnel
    if [ -n "$CLOUDFLARE_TUNNEL_TOKEN" ]; then
        log "Cloudflare Tunnel enabled, starting cloudflared..."
        docker compose --profile cloudflare up -d cloudflared >> "$LOG_FILE" 2>&1
    else
        # Stop cloudflared if it was previously running but token was removed
        docker compose --profile cloudflare stop cloudflared 2>/dev/null || true
    fi
}

# Function to stop containers
stop_containers() {
    log "Stopping OnionPress containers..."
    cd "$DOCKER_DIR"
    # Stop cloudflared first if running (profile containers need --profile to be addressed)
    docker compose --profile cloudflare down 2>&1 | tee -a "$LOG_FILE"
    log "Containers stopped"
}

# Function to get container status
get_status() {
    cd "$DOCKER_DIR"
    # Convert newline-delimited JSON to JSON array
    docker compose ps --format json 2>/dev/null | jq -s '.' 2>/dev/null || echo "[]"
}

# Function to get onion address (non-blocking, single attempt)
get_onion_address() {
    cd "$DOCKER_DIR"
    ONION_ADDR=$(docker compose exec -T tor cat /var/lib/tor/hidden_service/wordpress/hostname 2>/dev/null || echo "")
    if [ ! -z "$ONION_ADDR" ]; then
        echo "$ONION_ADDR"
        return 0
    fi
    echo "Generating..."
    return 1
}

# Function to get healthcheck onion address (non-blocking, single attempt)
get_healthcheck_address() {
    cd "$DOCKER_DIR"
    local addr
    addr=$(docker compose exec -T tor cat /var/lib/tor/hidden_service/healthcheck/hostname 2>/dev/null || echo "")
    if [ ! -z "$addr" ]; then
        echo "$addr"
        # Save to data dir for menubar app to read
        echo "$addr" > "$DATA_DIR/healthcheck-address"
        return 0
    fi
    return 1
}

# Function to wait for services to be ready using active probing
wait_for_services() {
    cd "$DOCKER_DIR"
    local max_wait=120
    local waited=0
    local wp_ready=false
    local onion_ready=false
    local onion_addr=""

    log "Waiting for services to be ready (polling with curl)..."

    while [ $waited -lt $max_wait ]; do
        # Step 1: Get onion address if we don't have it yet
        if [ -z "$onion_addr" ] || [ "$onion_addr" = "Generating..." ]; then
            onion_addr=$(docker compose exec -T tor cat /var/lib/tor/hidden_service/wordpress/hostname 2>/dev/null || echo "")
        fi

        # Step 2: Check if WordPress is responding locally
        if [ "$wp_ready" = false ]; then
            if curl -s --max-time 3 http://localhost:8080 >/dev/null 2>&1; then
                log "✓ WordPress is responding on localhost:8080"
                wp_ready=true

                # If WordPress is not yet installed, skip waiting for Tor
                if ! wp_is_installed; then
                    log "WordPress not installed — setup required, skipping Tor wait"
                    return 0
                fi
            fi
        fi

        # Step 3: Check Tor bootstrap and WordPress reachable from Tor container
        # (SOCKS proxy doesn't work through Colima VM port forwarding,
        # so we test the actual path: tor -> wordpress via Docker network)
        if [ "$onion_ready" = false ] && [ ! -z "$onion_addr" ] && [ "$onion_addr" != "Generating..." ]; then
            # Check Tor is bootstrapped
            if docker compose logs tor 2>/dev/null | grep -q "Bootstrapped 100% (done)"; then
                # Check WordPress is reachable from Tor container
                if docker compose exec -T tor wget -q -O /dev/null --timeout=5 http://wordpress:80/ 2>/dev/null; then
                    log "✓ Onion service ready: ${onion_addr}"
                    onion_ready=true
                fi
            fi
        fi

        # Both ready — done
        if [ "$wp_ready" = true ] && [ "$onion_ready" = true ]; then
            log "All services are ready after ${waited}s"
            ONION_ADDR="$onion_addr"
            # Read and save healthcheck address
            if hc_addr=$(get_healthcheck_address); then
                log "Healthcheck address: ${hc_addr}"
            fi

            # Write onion address to shared volume for WordPress plugins
            docker exec onionpress-tor cp /var/lib/tor/hidden_service/wordpress/hostname /var/lib/onionpress/onion_address 2>>"$LOG_FILE" && \
                log "✓ Onion address written to shared volume" || \
                log "WARNING: Failed to write onion address to shared volume"

            return 0
        fi

        sleep 2
        waited=$((waited + 2))
    done

    # Timed out — report what we have
    log "WARNING: Services not fully ready after ${max_wait}s (wp=${wp_ready}, onion=${onion_ready})"
    if [ ! -z "$onion_addr" ] && [ "$onion_addr" != "Generating..." ]; then
        ONION_ADDR="$onion_addr"
    else
        ONION_ADDR="Generating..."
    fi
    return 1
}

# Main execution
main() {
    case "${1:-start}" in
        start)
            # Detect container runtime
            if ! RUNTIME=$(detect_container_runtime); then
                install_docker
                exit $?
            fi

            log "Detected container runtime: $RUNTIME"

            # Create symlink for Docker socket if needed
            # Colima forwards the socket to ~/.colima/default/docker.sock
            # but we configure DOCKER_HOST to use ~/.onionpress/colima/default/docker.sock
            # Create symlink to bridge this gap
            SOCKET_DIR="$COLIMA_HOME/default"
            SOCKET_PATH="$SOCKET_DIR/docker.sock"
            COLIMA_SOCKET="$HOME/.colima/default/docker.sock"

            if [ -S "$COLIMA_SOCKET" ]; then
                if [ ! -e "$SOCKET_PATH" ] || [ ! -S "$SOCKET_PATH" ]; then
                    log "Creating Docker socket symlink..."
                    mkdir -p "$SOCKET_DIR"
                    ln -sf "$COLIMA_SOCKET" "$SOCKET_PATH"
                    log "Docker socket symlink created: $SOCKET_PATH -> $COLIMA_SOCKET"
                fi
            fi

            # Setup database passwords (generates random passwords on first run)
            setup_db_passwords

            # Start containers
            start_containers

            # Actively poll until services are ready (replaces fixed sleep)
            wait_for_services

            log "OnionPress is running!"
            log "Onion address: $ONION_ADDR"
            log "Local access: http://localhost:8080"
            log "OnionPress is now running! Check the menu bar for status."
            ;;

        stop)
            setup_db_passwords
            stop_containers
            ;;

        restart)
            setup_db_passwords
            stop_containers
            start_containers
            wait_for_services
            ;;

        status)
            get_status
            ;;

        address)
            get_onion_address
            ;;

        start-tor)
            setup_db_passwords
            cd "$DOCKER_DIR"
            docker compose up -d tor >> "$LOG_FILE" 2>&1
            log "Tor container started"
            ;;

        import-key)
            import_key "$2"
            ;;

        logs)
            cd "$DOCKER_DIR"
            docker compose logs -f
            ;;

        *)
            echo "Usage: $0 {start|stop|restart|status|address|start-tor|import-key|logs}"
            exit 1
            ;;
    esac
}

main "$@"
